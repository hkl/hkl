{"tagline":"The hkl language","body":"The hkl language - ( /ˈhekəl/ )\r\n===\r\n\r\nTo build right now:  \r\n\r\nYou _should_ only have to do this once.\r\n\r\n`$ ./auto-build-env`\r\n\r\nThen as normal:\r\n\r\n`$ make`\r\n\r\n##How to hkl\r\n\r\n###Hello, hekəl\r\n######what we type in:\r\n```lua\r\nputs \"Hello, hekəl\"\r\n```\r\n######what comes out:\r\n```\r\nHello, hekəl\r\n```\r\nhkl is simple. A hello world can't get much simpler than this.\r\n\r\n###Let's make things weird\r\nWe will begin by calculating a big prime number.\r\n######what we type in:\r\n```lua\r\n// -- Load only the sqrt function --\r\nsqrt = interface \"math\" sqrt: cfunc end\r\n\r\nisprime = function(n)\r\n  sqn = sqrt(n)\r\n  ok = true\r\n  m = 2 while m <= sqn if n % m == 0 ok = false break end\r\n    m = m + 1\r\n  end\r\n  return ok\r\nend\r\n\r\nj = 2\r\nprime = 0 while prime < 10001\r\n  if isprime(j)\r\n    prime = prime + 1\r\n  end\r\n  j = j + 1\r\nend\r\n\r\nputs (j - 1)\r\n```\r\n######what comes out:\r\n```\r\n104743\r\n```\r\n\r\n###Well that escalated quickly. What just happened?\r\nIf all went well, we just calculated the 10001st prime number.\r\n\r\nNow lets take a look at whats going on here. We'll start with that function:\r\n```lua\r\nisprime = function(n)\r\n ...\r\nend\r\n```\r\nThis is most explicit way to make a function in hkl. In this case, we created\r\na function called **isprime**, the thing being handed to the function is obviously a\r\nnumber **n**.\r\n\r\nhkl doesn't really care how you write things so there are many valid ways to\r\nwrite a function.\r\n```lua\r\nfunction() end\r\n```\r\nThis is all that is required to make a function in hkl. Note that functions must be\r\nclosed off with a trailing **end** keyword. Everything in between that **)** and\r\n**end** is called a **scope**. The scope is the body of a function.\r\n\r\nI mentioned that hkl doesn't *really* care how you write things, but there are some\r\nexceptions:\r\n\r\nYou cannot create a function without explicitly writing **\"function\"**.\r\n```lua\r\nsome_function = Function(parameter, another)\r\n  // -- Not Valid. hkl is case-sensitive --\r\nend\r\n```\r\n\r\nNot using commas in the parameter list.\r\n```lua\r\nsome_function = function(parameter another)\r\n  // -- Not Valid. --\r\nend\r\n```\r\n\r\nYou also cannot create a function with a space in it's name.\r\n```lua\r\nsome function = function(parameter, another)\r\n  // -- Not Valid. (Hint: not entirely true) --\r\nend\r\n```\r\n\r\nThis is valid however, but probably not the nicest to look at.\r\n```lua\r\nsome_function\r\n\r\n=function\r\n (\r\n  parameter,\r\n  another\r\n )\r\nend\r\n```\r\n\r\n###The \"types\" of hkl\r\nhkl has a small set of essential data types you can use. Together they\r\nmake up 99% of all you would ever need.\r\n\r\n######what we type in:\r\n```lua\r\nmy_int = 12\r\nputs typeof my_int\r\n\r\nmy_real = 3e99\r\nputs typeof my_real\r\n\r\nmy_string = \"hello\"\r\nputs typeof my_string\r\n\r\nmy_type = cdata\r\nputs typeof my_type\r\n\r\nmy_array = [1, 2]\r\nputs typeof my_array\r\n\r\nmy_hash = { hkl: \"awesome\" }\r\nputs typeof my_hash\r\n\r\nmy_function = function() end\r\nputs typeof my_function\r\n```\r\n######what comes out:\r\n```\r\nint\r\nreal\r\nstring\r\ntype\r\narray\r\nhash\r\nfunc\r\n```\r\n\r\n\r\n###Creating Variables\r\nWhat use is a programming language without a way to store data.\r\nIn hkl, data is stored in variables. Variables are identified by a single word.\r\nBelow are some examples of variable declarations:\r\n\r\nI want a number\r\n```lua\r\nnumber = 1000\r\n```\r\nI want some text\r\n```lua\r\ntext = \"Hey there, buddy\"\r\n```\r\nGive me a table\r\n```lua\r\nmy_strings = {\"oh\", \"why\", \"is\", \"hkl\", \"so\", \"neat?\"}\r\n```\r\nTell me the truth\r\n```lua\r\nawesome = true\r\n```\r\nWhat about a function?\r\n```lua\r\nsome_function = function(arg1, arg2) end\r\n```\r\nAssigning a value from another variable, so easy!\r\n```lua\r\nNothing = could_be_anything\r\n```\r\n\r\nVariables created inside a scope are called **local** variables.\r\nThey can only be used inside the scope they are declared.\r\n######what we type in:\r\n```lua\r\nprint = function()\r\n  text = \"Hello from inside print!\"\r\n  puts text\r\nend\r\n\r\nprint()\r\nputs text\r\n```\r\n######what comes out:\r\n```\r\nHello from inside print!\r\nnil\r\n```\r\n\r\nSince the variable text was declared within the scope of print\r\nonly, we can't use it when we are outside of print. Not too odd.\r\nBut what if text was declared before it was declared in print?\r\n######what we type in:\r\n```lua\r\ntext = \"What is going to happen?\"\r\n\r\nprint = function()\r\n  text = \"Hello from inside print!\"\r\n  puts text\r\nend\r\n\r\nprint()\r\nputs text\r\n```\r\n######what comes out:\r\n```\r\nHello from inside print!\r\nHello from inside print!\r\n```\r\n\r\nIs that what you expected? Since text was already declared when we declared\r\nprint, text retained it's value after the function was finished.\r\n\r\n###Loops\r\nhkl relies primarily on the most underrated of control structures, the *while-loop*\r\n######what we type in:\r\n```lua\r\ni = 0\r\nwhile i < 5\r\n i = i + 1 \r\n puts i as string * 3\r\nend\r\n```\r\n######what comes out:\r\n```\r\n111\r\n222\r\n333\r\n444\r\n555\r\n```","note":"Don't delete this file! It's used internally to help with page regeneration.","google":"","name":"Hkl"}